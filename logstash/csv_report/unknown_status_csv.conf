input {
 elasticsearch {
	hosts => "localhost"
    index => "anttail-gwprocessor-logs*"
    query => '{ 
	"query": {
		"bool": {
		  "must": [
			{
			  "query_string": {
				"query": "\"Received a message from\"",
				"analyze_wildcard": true
			  }
			},
			{
			  "range": {
				"@timestamp": {
				  "gte": "now-1d/d",
				  "lte": "now/d",
				  "format": "epoch_millis"
				}
			  }
			}
		  ],
		  "must_not": []
		}
		}
	}'
  }
}
filter {
	if "Received a message from" in [message]{
	aggregate {
		task_id => "%{gateway_node_Id}"
		code => "
			map['message'] ||= event.get('message')
			map['gateway_node_Id'] ||= event.get('gateway_node_Id')
			map['Client'] ||= event.get('Client')
			map['Cause'] ||= event.get('Cause')
		"
    		push_previous_map_as_event => false
		push_map_as_event_on_timeout => true
		timeout => 0
		timeout_task_id_field => "gateway_node_Id"
		timeout_tags => ["aggregate"]
	}
	if "aggregate" not in [tags] {
                drop{}
        }
	ruby {
        init => "
            begin
                @@csv_file    = 'unknown_sensor_gateway.csv'
                @@csv_headers = ['Provider','Type','Node Name']
                if File.zero?(@@csv_file) || !File.exist?(@@csv_file)
                    CSV.open(@@csv_file, 'w') do |csv|
                        csv << @@csv_headers
                    end
                end
            end
        "
	code => ""
        }	
	}
}
output {
	if "aggregate" in [tags] {
        csv {
		path => "unknown_sensor_gateway.csv" 
		fields => ["Client","Cause","gateway_node_Id"]
        }
	}
}
